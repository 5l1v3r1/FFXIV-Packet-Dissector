/*
 * This tool is used to convert JSON IPC schemas to Lua dissectors.
 */

const fs = require('fs')
let files = fs.readdirSync('./js')
fs.readdirSync('../src').forEach(file => {
  if (file.startsWith('ffxiv_ipc_') && file.endsWith('_gen.lua')) {
    fs.unlinkSync(`../src/${file}`)
  }
})

const snakeCase = name => name.replace(/\s*([A-Z]+)/g, (m0, m1, index) => `${index ? '_' : ''}${m1.toLowerCase()}`)
const tvbMethod = function (type) {
  if (type.startsWith('uint')) {
    return type === 'uint64' ? 'le_uint64' : 'le_uint'
  } else if (type === 'float') {
    return 'le_float'
  }

  return type
}

const itemAppend = function (item) {
  if (!item.append) return ''

  let output = `${snakeCase(item.name)}_val`
  switch (item.append) {
    case 'enum':
      if (item.enum) {
        output = `(${item.enum}[${output}] or "(unknown)")`
      }
      break
    case 'hex':
      output = `string.format('%0${item.length / 4}x', ${output}))`
      break
    case 'val':
    default:
      break
  }

  let outputName = `${item.name}: `
  if (item.append_name === false) {
    outputName = ''
  } else if (item.label) {
    outputName = `" .. (${Object.keys(item.label)
      .map(key => `label_${item.key}_${snakeCase(key)}[${snakeCase(key)}_val]`).join(' or ')}) .. "`
  }

  return `
  local ${item.key}_display = ", ${outputName}" .. ${output}
  pktinfo.cols.info:append(${item.key}_display)
  tree:append_text(${item.key}_display)\n`
}

const itemLabel = function (item) {
  return `(${Object.keys(item.label)
    .map(key => `label_${item.key}_${snakeCase(key)}[${snakeCase(key)}_val]`).join(' or ')} or "${item.name}") .. ": " .. ${item.key}_val`
}

const table = function (name, array, rawValue = false) {
  return `${name} = {
${array.map(({ key, value }) => `  ${tableKey(key)} = ${tableValue(value, rawValue)},`).join('\n')}
}`
}

const tableKey = function (key) {
  return typeof key === 'number' ? `[${key}]` : `${key}`
}

const tableValue = function (val, raw = false) {
  return (raw || typeof val === 'number') ? `${val}` : `"${val}"`
}

let globalEnums = []
const generateLuaDissector = function (name, obj) {
  let fields = obj.fields || (obj.structs && obj.structs[0] && obj.structs[0].fields)
  if (!fields || !fields.length) return ''
  let requireDB = false
  let requireEnum = false

  fields = fields.map(oldItem => {
    const item = { ...oldItem }
    item.key = snakeCase(item.name)
    if (item.enum) {
      if (item.enum.startsWith('$')) {
        item.enum = item.enum.replace('$', 'db.')
        requireDB = true
      } else {
        item.enum = `enum.reverse.${snakeCase(item.enum)}`
        requireEnum = true
      }
    }
    return item
  })

  if (obj.enums) {
    globalEnums = globalEnums.concat(obj.enums.map(enumItem => {
      return {
        key: snakeCase(enumItem.name),
        ...enumItem
      }
    }))
  }

  let snakeName = snakeCase(name)
  let maxLength = fields.reduce((max, item) => Math.max(max, item.key.length), 0)

  return `-- This file is generated by tools/json2lua.js
${requireDB ? `
local db = require('ffxiv_db')` : ''
}${requireEnum ? `
local enum = require('ffxiv_enum')` : ''
}${
  fields.map(item => {
    if (!item.label) return ''

    return Object.keys(item.label)
      .map(key => '\n' + table(`local label_${item.key}_${snakeCase(key)}`, item.label[key]))
      .join('')
  }).filter(a => a).join('')
}
local ffxiv_ipc_${snakeName} = Proto("ffxiv_ipc_${snakeName}", "FFXIV-IPC ${name}")

local ${snakeName}_fields = {${fields.map(item => `
  ${item.key}${' '.repeat(maxLength - item.key.length)} = ProtoField.${item.type}("ffxiv_ipc_${snakeName}.${
  item.key}", "${item.name}", base.${item.base || 'DEC'}${item.enum ? `, ${item.enum}` : ''}),`).join('')}
}

ffxiv_ipc_${snakeName}.fields = ${snakeName}_fields

function ffxiv_ipc_${snakeName}.dissector(tvbuf, pktinfo, root)
  local tree = root:add(ffxiv_ipc_${snakeName}, tvbuf)
  pktinfo.cols.info:set("${name}")

${fields.map(item => `${item.check_length ? `
if tvbuf:len() > ${item.offset + (item.length || 0)} then` : ''}
  -- dissect the ${item.key} field
  local ${item.key}_tvbr = tvbuf:range(${item.offset}${item.length ? `, ${item.length}` : ''})
  local ${item.key}_val  = ${item.key}_tvbr:${item.tvb_method || `${tvbMethod(item.type)}()`}
  tree:${item.add_le === false ? 'add' : 'add_le'}(${snakeName}_fields.${item.key}, ${item.key}_tvbr, ${item.key}_val${item.label ? `, ${itemLabel(item)}` : ''})
${itemAppend(item)}${item.check_length ? 'end\n' : ''}`).join('')}

  return tvbuf:len()
end`
}

const ipcTypes = {}
const addTypes = ({ name, type, version }) => {
  if (typeof type === 'object') {
    return Object.keys(type).forEach(version => {
      addTypes({ name, type: type[version], version })
    })
  }

  if (!ipcTypes[version]) {
    ipcTypes[version] = []
  }

  ipcTypes[version].push({
    name: name.replace(/ /g, ''),
    type
  })
}

for (let file of files) {
  const obj = JSON.parse(fs.readFileSync('./js/' + file))
  const name = obj.name || file.replace('.json', '')

  if (obj.name) {
    addTypes(obj)
    fs.writeFileSync(`../src/ffxiv_ipc_${snakeCase(name)}_gen.lua`, generateLuaDissector(name, obj))
  }

  if (obj.aliases && obj.aliases.length) {
    for (let alias of obj.aliases) {
      addTypes(alias)

      fs.writeFileSync(`../src/ffxiv_ipc_${snakeCase(alias.name)}_gen.lua`, generateLuaDissector(alias.name, obj))
    }
  }
}

Object.keys(ipcTypes).forEach(version => {
  const ipcTypeContent = `-- This file is generated by tools/json2lua.js

local M = {}
${table('M.types', ipcTypes[version].map(({ name, type }) => ({
    key: name,
    value: typeof type === 'number' ? `0x${('000' + type.toString(16)).substr(-4)}` : type
  })), true)}

function M.getDissector(type)
${'  ' + ipcTypes[version].map(({ name }) => `if type == M.types.${name} then
    return Dissector.get('ffxiv_ipc_${snakeCase(name)}')
  else`).join('')}
    return nil
  end
end

return M
`
  fs.writeFileSync(`../src/ffxiv_ipc_type_${version.replace(/\./g, '_')}.lua`, ipcTypeContent)
})

if (globalEnums.length) {
  const enumContent = `-- This file is generated by tools/json2lua.js

local M = {
  forward = {},
  reverse = {}
}

local function makeValString(enumTable)
  local t = {}
  for name,num in pairs(enumTable) do
      t[num] = name
  end
  return t
end

${globalEnums.map(item => `
${table(`M.forward.${item.key}`, item.values)}
M.reverse.${item.key} = makeValString(M.forward.${item.key})`).join('\n')}

return M
`

  fs.writeFileSync(`../src/ffxiv_enum.lua`, enumContent)
}
